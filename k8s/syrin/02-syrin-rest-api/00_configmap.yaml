apiVersion: v1
data:
  main.py: |-
    import logging
    from flask import Flask, request, jsonify
    import threading
    import os
    import pika
    import json  # Importar a biblioteca JSON

    # Configurar o log de nível INFO
    logging.basicConfig(level=logging.INFO)

    # Desativar logs de debug do pika, configurando para WARNING ou superior
    logging.getLogger("pika").setLevel(logging.WARNING)

    # Carregar configurações do RabbitMQ das variáveis de ambiente
    rabbitmq_host = os.getenv('RABBITMQ_HOST', '')
    rabbitmq_port = int(os.getenv('RABBITMQ_PORT', 30672))
    rabbitmq_vhost = os.getenv('RABBITMQ_VHOST', 'syrin')
    rabbitmq_user = os.getenv('RABBITMQ_USER', '')
    rabbitmq_pass = os.getenv('RABBITMQ_PASS', '')

    app = Flask(__name__)

    def declare_queues():
        """Função para declarar as filas necessárias ao iniciar o Flask."""
        # Conectar ao RabbitMQ
        credentials = pika.PlainCredentials(rabbitmq_user, rabbitmq_pass)
        parameters = pika.ConnectionParameters(
            host=rabbitmq_host,
            port=rabbitmq_port,
            virtual_host=rabbitmq_vhost,
            credentials=credentials
        )

        connection = pika.BlockingConnection(parameters)
        channel = connection.channel()

        # Declarar as filas para garantir que existam
        queues = ['000_notification_warning', '000_notification_error']
        for queue in queues:
            channel.queue_declare(queue=queue, durable=True)
            logging.info(f"Fila '{queue}' verificada ou criada.")

        connection.close()

    def send_text_to_queue(text, level):
        # Conectar ao RabbitMQ
        credentials = pika.PlainCredentials(rabbitmq_user, rabbitmq_pass)
        parameters = pika.ConnectionParameters(
            host=rabbitmq_host,
            port=rabbitmq_port,
            virtual_host=rabbitmq_vhost,
            credentials=credentials
        )

        connection = pika.BlockingConnection(parameters)
        channel = connection.channel()

        # Montar a mensagem no formato JSON
        message = json.dumps({"text": text, "level": level})

        # Enviar o texto para a fila correspondente
        channel.basic_publish(
            exchange='',
            routing_key='000_notification_' + level,
            body=message,
            properties=pika.BasicProperties(
                delivery_mode=2,  # Faz a mensagem persistir
            )
        )

        # Fechar a conexão
        connection.close()

    @app.route('/api/text-to-speech', methods=['POST'])
    def text_to_speech():
        data = request.json

        # Loga o conteúdo da requisição recebida
        app.logger.info(f"Requisição recebida com os dados: {data}")

        if not data or ('text' not in data and 'msg' not in data):
            app.logger.error("Nenhum texto ou mensagem fornecidos")
            return jsonify({"error": "Nenhum texto ou mensagem fornecidos"}), 400

        # Verifica de qual campo a mensagem foi recebida
        if 'text' in data:
            text = data['text']
            field_source = 'text'
            level = "warning"
        elif 'msg' in data:  # uptime-kuma
            text = data['msg']
            field_source = 'msg'
            level = "error"
        else:
            return jsonify({"error": "Nenhum campo de texto fornecido"}), 400

        # Processa o texto em uma thread separada
        threading.Thread(target=send_text_to_queue, args=(text, level)).start()

        # Responde imediatamente que o processamento foi enfileirado
        return jsonify({"message": f"Requisição recebida do campo '{field_source}', processamento em andamento."}), 200

    declare_queues()


kind: ConfigMap
metadata:
  name: cm-syrin-rest-api
  namespace: syrin